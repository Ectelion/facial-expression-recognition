## Libs
library(rpart)
library(cvTools)
library(FSelector)

## Load configurations 
source('GlobalVars.R')

## Find euclidean distances for two sets of 2D points. Returns a vector 
## with distances for each of the corresponding rows in the sets

euclideanDistances <- function(pointsSet1, pointsSet2) {
    if (length(pointsSet1) != length(pointsSet2)) {
        stop("Invalid input: lengths of the vectors are not equal")
    }
    xDist = pointsSet1[, 1] - pointsSet2[, 1]
    yDist = pointsSet1[, 2] - pointsSet2[, 2]
    eucDist = sqrt(xDist * xDist + yDist * yDist)
    eucDist
}

## Copies all the files from a source to a target directory 

copyAllFiles <- function(sourceDirectory, targetDirectory) {
    files <- list.files(sourceDirectory, recursive = FALSE)
    lapply(files, 
        function(filePath) {
            path = paste(sourceDirectory, filePath, sep = "")
            file.copy(from = path, to = targetDirectory)
        }
      )
}

## Processes the Cohn-Kanade data set and returns a list of paths to labeled emotion files
## Example: findLabeledEmotionFiles(emotionLabels$happy)

findLabeledEmotionFiles <- function(emotionCode, folder = emotionLabelsFolder) {
    files <- list.files(folder, recursive = TRUE)
    emotionLabelsFiles <- c()
    lapply(files, 
        function(file) {
            path = paste(folder, file, sep = "/")
            if (read.table(path) == emotionCode) {
                emotionLabelsFiles <<- c(emotionLabelsFiles, path)
            }
        }
    )
    emotionLabelsFiles
}


## Processes the Cohn-Kanade data set, extracting the most relevant landmarks files 
## for a particular facial expression
## Example: findAndCopyEmotionFiles(emotionLabels$happy)

findAndCopyEmotionFiles <- function(emotionCode, targetDirectory = outputFolder) {
    files <- findLabeledEmotionFiles(emotionCode);
    lapply(files, 
        function(path) {
            sPos <- regexpr("S[[:digit:]][[:digit:]][[:digit:]]/", path)   
            endPos <- regexpr("/[[:digit:]][[:digit:]][[:digit:]]/", path)
            if (endPos != -1) {
                endPos <- endPos + 4
                copyFromFolder <- substring(path, sPos, endPos)
                copyFromFolder <- paste(landmarksFolder, copyFromFolder, sep = "/")
                copyToFolder   <- substring(path, sPos, endPos - 4 - 1)
                newFolderFullPath <- paste(targetDirectory, copyToFolder, sep = "/")
                if (!file.exists(newFolderFullPath)) {
                    dir.create(newFolderFullPath)
                }
                copyAllFiles(copyFromFolder, newFolderFullPath)
                paste(copyFromFolder, newFolderFullPath, sep = "=>")
            } else {
                NA
            }
        }
    )
}

## Creates a set of folders, specified in @folderPathsList, within the @targetDirectory   

createFolders <- function(folderPathsList = emotionFolders, targetDirectory = outputFolder) {
    lapply(folderPathsList, 
        function(folderPath) {
            if (!file.exists(folderPath)) {
                dir.create(folderPath)
                paste(folderPath, "-> folder created")
            }
        }
    )
} 
    
## Processes the list of files, generated by findAndCopyEmotionFiles() function,  
## generating n.dat (netral face landmarks) and em.dat (emotional face landmarks) files for each subject 

preprocessEmotionFilePaths <- function(inputFolderPath = happinessFolder) {
    folders <- list.dirs(inputFolderPath, recursive = FALSE)
    lapply(folders, 
        function(folder) { 
            files <- list.files(folder, recursive = FALSE);
            firstFile <- paste(folder, files[1], sep = "/"); 
            lastFile <- paste(folder, files[length(files)], sep = "/"); 
            file.copy(from = firstFile, to = paste(folder, "n.dat", sep = "/"));
            file.copy(from = lastFile,  to = paste(folder, "em.dat", sep = "/"));
        }
    )
}

## Processes landmarks files within the input folder, generating normalized_change_xy.dat 
## file with normalized change between landmarks in n.dat and em.dat files

createNormalizedLandmarkFiles <- function(inputFolderPath = happinessFolder) {
    folders <- list.dirs(inputFolderPath, recursive = FALSE)
    lapply(folders, 
          function(folder) { 
              neutralFace   <- read.table(paste(folder,"n.dat", sep = "/"))
              emotionalFace <- read.table(paste(folder,"em.dat", sep = "/"))
              distances     <- emotionalFace - neutralFace
              normalizedDistances <- normalizeMatrix(distances)
              destinationPath = paste(folder, "normalized_change_xy.dat", sep = "/")
              file.create(destinationPath, overwrite=TRUE)
              write.table(normalizedDistances, file = destinationPath, row.names = FALSE, col.names = FALSE)  # ncolumns=2
              paste(destinationPath, "created")
          }
    )
}

## Returns: labeled training data with normalized landmark displacements as features

loadData <- function(inputFolderPath = faceExpressionsFolder) {
    emotionCode <- 1
    trainingData <- data.frame()
    labelsColumn <- data.frame()
    
    lapply(emotionTitles, 
        function(emotionTitle) {
            emotionFolder <- paste(inputFolderPath, emotionTitle, sep = "/")
            folders <- list.dirs(emotionFolder, recursive = FALSE)
              cnt <- 0
              for (folder in folders) { 
                    normalizedDistances <- read.table(paste(folder,"normalized_change_xy.dat", sep = "/"))
                    features <- c(normalizedDistances[, 1], normalizedDistances[, 2])  	  	
                    trainingData <<- rbind.data.frame(trainingData, features)
                    labelsColumn <<- rbind.data.frame(labelsColumn, emotionCode)
            }
            emotionCode <<- emotionCode + 1  
        }
    )
    trainingData <- cbind.data.frame(trainingData, labelsColumn)
    colnames(trainingData) <- c(paste("X", 1:136, sep = ""), "emotion")
    rownames(trainingData) <- NULL
    trainingData
}

## Returns: labeled training data with peak emotions as features
## @loadNeutral - using this, neutral emotions may be optionally included
## @balanceLabels - balances the number of neutral faces in the data to avoid biased training
## @scaleData - whether the data should be scaled to zero mean and standard deviation of 1 

loadPeakEmotions <- function(inputFolderPath = faceExpressionsFolder, loadNeutral = FALSE, balanceLabels = FALSE, scaleData = TRUE) {
    emotionCode <- 1
    trainingData <- data.frame()
    labelsColumn <- data.frame()
    cnt <- 0
    
    lapply(emotionTitles, 
        function(emotionTitle) {
            emotionFolder <- paste(inputFolderPath, emotionTitle, sep = "/")
            folders <- list.dirs(emotionFolder, recursive = FALSE)
          
            for (folder in folders) { 
                emotionalFace <- read.table(paste(folder, "em.dat", sep = "/"))
                if (scaleData) {
                    emotionalFace <- normalizeMatrix(emotionalFace)
                }
                emotionalFeatures <- c(emotionalFace[, 1], emotionalFace[, 2])  	  	
                trainingData <<- rbind.data.frame(trainingData, emotionalFeatures)
                labelsColumn <<- rbind.data.frame(labelsColumn, emotionCode)
                
                if (loadNeutral) {
                    if (!balanceLabels || cnt%%7 == 0) {
                        neutralFace <- read.table(paste(folder, "n.dat", sep = "/"))
                        if (scaleData) {
                            neutralFace <- normalizeMatrix(neutralFace)
                        }
                        neutralFeatures <- c(neutralFace[, 1], neutralFace[, 2])
                        trainingData <<- rbind.data.frame(trainingData, neutralFeatures)
                        labelsColumn <<- rbind.data.frame(labelsColumn, 8)
                    }
                }
                cnt <<- cnt + 1
            }
            emotionCode <<- emotionCode + 1  
        }
    )
    trainingData <- cbind.data.frame(trainingData, labelsColumn)
    colnames(trainingData) <- c(paste("X", 1:136, sep = ""), "emotion")
    rownames(trainingData) <- NULL
    trainingData
}

normalizeMatrix <- function(matrix) {
    col1   <- matrix[, 1]
    col2   <- matrix[, 2]
    matrix[, 1] <- normalizeVector(col1)
    matrix[, 2] <- normalizeVector(col2)
    matrix
}

normalizeVector <- function(vector) {
    s <- sqrt(var(vector))
    normalizedVector <- (vector - mean(vector)) / s
    normalizedVector
}

## Generates a graph representing average landmarks change between neutral and emotional faces from the Cohn-Kanade data set

plotLandmarkChangesSummary <- function() {
    res <- analyzeFaceExpressions()
    Landmark_ID <- 1:length(res)
    Average_Change <- res
    plot(Landmark_ID, Average_Change, col=ifelse(Average_Change >= 9, "red", "black"), lwd = 4, type = 'p')
}

## Visualizes face change, plotting the peak and neutral emotions 

plotEntry <- function(folder) {
    neutralFace   <- read.table(paste(folder,"n.dat", sep = "/"))
    emotionalFace <- read.table(paste(folder,"em.dat", sep = "/"))
    plot(neutralFace[, 1], neutralFace[, 2])
    plot(emotionalFace[, 1], emotionalFace[, 2])
    plot(AU_ID, Average_Change, col = ifelse(Average_Change >= 9, "orange", "black"), lwd = 4, type = 'p')
}

relevantDTFeatures <- function(dataSet) {
    #  c("X52", "X87", "X117", "X102", "X118", "X120", "X125", "X92", "X89", "X101", "X123")
    dataSet[, c("X52", "X87", "X89", "X92", "X101", "X102", "X117", "X118", "X120", "X123")]
}

## * Part 1: Read input files that describe landmarks positions for neutral and emotional faces
## Reads files in the following way:
## 	1) Scans all the folders in the input folder 
## 	2) Searches for n.dat and em.dat files that store neutral and an emotional expressions
## * Part 2: Find average landmarks change across all the faces 

analyzeFaceExpressions <- function(inputFolderPath = happinessFolder) {
    landmarksFolders <- list.dirs(inputFolderPath, recursive = FALSE)
    sum          <- list()
    neutralSum   <- list()
    emotionalSum <- list()
    cnt <- 1
         
    lapply(landmarksFolders, 
        function(folder) {
            neutralFace   <- read.table(paste(folder, "n.dat", sep = "/"))
            emotionalFace <- read.table(paste(folder, "em.dat", sep = "/"))
            distances     <- euclideanDistances(neutralFace, emotionalFace)
            if (cnt == 1) {
                sum          <<- distances
                neutralSum   <<- neutralFace
                emotionalSum <<- emotionalFace
            } else {
                sum          <<- sum + distances
                neutralSum   <<- neutralSum + neutralFace
                emotionalSum <<- emotionalSum + emotionalFace
            }
            cnt <<- cnt + 1
            if (cnt == 100) {
                cnt <<- 1
            }
        }
    )
    ## Obtain the average change of landmarks across all faces
    neutralAvg   <- neutralSum / cnt
    emotionalAvg <- emotionalSum / cnt  
    
    ## Constructing Face maps - visualization characterizing average changes of landmarks across all faces 
    dataToPlot <- neutralAvg
    dataToPlot <- rbind(dataToPlot, emotionalAvg)
    len <- nrow(dataToPlot)
    dataToPlot <- cbind(dataToPlot, rowId = 1:len)
    plot(dataToPlot[, 1], -dataToPlot[, 2], col=ifelse(dataToPlot$rowId > len/2, "red", "black"), lwd = 4, type = 'p')
  
    ## Visualizations:
    ## plot(neutralAvg[, 1], neutralAvg[, 2])
    ## plot(emotionalAvg[, 1], emotionalAvg[, 2])
    ## plot(AU_ID, Average_Change, col = ifelse(Average_Change >= 9, "orange", "black"), lwd = 4, type = 'p')
  
    ## Obtain the average change of landmarks across all faces
    totalAvg <- sum / cnt
    totalAvg
}

## Processes the data set and identifies entries without emotional labels

findUnlabeledData <- function() {
    f_lb <- list.files(emotionLabelsFolder)
    folders_lb <- c()
    lapply(f_lb, function(folder) {
        subjF <- paste(emotionLabelsFolder, folder, sep = "/")
        f <- list.files(subjF)
        for (imageFolder in f) { 
            folders_lb <<- c(folders_lb, paste(folder, imageFolder, sep = "/"))
        }
    })
    labeled <- list.files(emotionLabelsFolder, recursive = T)
    labeled_sub <- substring(labeled, 1, 8)
    unlabeled <- setdiff(folders_lb, labeled_sub)
    unlabeled
}

## Find and copies all unlabeled image sequences to the target directory

copyUnlabeledData <- function(targetDirectory = "Unlabeled data") {
    if (!file.exists(targetDirectory)) {
        dir.create(targetDirectory)
    }
    folders <- findUnlabeledData()
    lapply(folders, 
        function(folderPath) {
            fromPath   <- paste(imagesFolder, folderPath, sep = "/")
            targetPath <- paste(targetDirectory, folderPath, sep = "/")
            if (!file.exists(targetPath)) {
                dir.create(targetPath)
            }
            file.copy(from = fromPath, to = targetDirectory)
        }
    )
}

## Given a data, generate new samples based on the data's distribution properties
## Caution: possible linear dependence between the features

generateData <- function(data, labelsColumnID = ncol(data), N = 30) {
    classes <- unique(data[, labelsColumnID])
    classesNum <- length(classes)
    featuresNum <- ncol(data) - 1
    groupedData <- split(data, data[, labelsColumnID]) 
    generatedData <- c()
    
    # For each class, estimate distribution properties and based on them generate new data 
    for (class in classes) {
        generatedRows <- c()
        for (featureId in 1:featuresNum) {
            classMean <- mean(groupedData[[class]][, featureId])
            classVariance <- var(groupedData[[class]][, featureId])
            generatedColumn <- rep(classMean, N) + rnorm(N, mean = 0, sd = 1) #rnorm(N, mean = classMean, sd = classVariance)
            generatedRows <- cbind(generatedRows, generatedColumn)
        }
        generatedRows <- cbind(generatedRows, rep(class, nrow(generatedRows)))
        generatedData <- rbind(generatedData, generatedRows)
    }
    colnames(generatedData) <- colnames(data)
    as.data.frame(generatedData)
}
